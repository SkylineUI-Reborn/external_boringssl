{
  "comments": [
    {
      "key": {
        "uuid": "611558c2_23399396",
        "filename": "Android.bp",
        "patchSetId": 1
      },
      "lineNbr": 34,
      "author": {
        "id": 1031048
      },
      "writtenOn": "2018-06-25T23:31:27Z",
      "side": 1,
      "message": "It occurs to me this is also a little off, though probably fine for now. If an STL type crosses a shared library API boundary, using a statically-linked libc++ is a little off. This is pretty much moot right now, since BoringSSL does not depend on the C++ runtime yet, though this might change. And I guess the STL is sufficiently uninteresting that passing types between two copies of the same STL is actually just fine. So I\u0027m tempted to leave this as-is for now, and wrestle with this more in the future.\n\nThe trigger is https://boringssl.googlesource.com/boringssl/+/a307cb7d5867924a34f69995b457d00db0783ad0 tests the waters of putting the STL in BoringSSL\u0027s API boundary. (+agl)\n\nThoughts?\n\nPS: Whyyyyyy must you all have so many STLs in Android?? :-(",
      "range": {
        "startLine": 34,
        "startChar": 24,
        "endLine": 34,
        "endChar": 31
      },
      "revId": "fc8a786995b661f44da82cba00d23b3f5e92653c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d5ca4789_0e79567e",
        "filename": "Android.bp",
        "patchSetId": 1
      },
      "lineNbr": 34,
      "author": {
        "id": 1042885
      },
      "writtenOn": "2018-06-26T15:03:46Z",
      "side": 1,
      "message": "\u003e It occurs to me this is also a little off, though probably fine for now. If an STL type crosses a shared library API boundary, using a statically-linked libc++ is a little off. This is pretty much moot right now, since BoringSSL does not depend on the C++ runtime yet, though this might change. And I guess the STL is sufficiently uninteresting that passing types between two copies of the same STL is actually just fine. So I\u0027m tempted to leave this as-is for now, and wrestle with this more in the future.\n\nSeems reasonable.  I don\u0027t know enough about the pitfalls here to have a lot of confidence, but what you say makes sense to me.\n\n\u003e PS: Whyyyyyy must you all have so many STLs in Android?? :-(\n\nI think it basically boils down to libc++ (static/shared) plus a bunch of legacy crap that we can\u0027t yet get rid of.",
      "parentUuid": "611558c2_23399396",
      "range": {
        "startLine": 34,
        "startChar": 24,
        "endLine": 34,
        "endChar": 31
      },
      "revId": "fc8a786995b661f44da82cba00d23b3f5e92653c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d9195c2a_1e4f85ca",
        "filename": "Android.bp",
        "patchSetId": 1
      },
      "lineNbr": 34,
      "author": {
        "id": 1031048
      },
      "writtenOn": "2018-06-26T15:46:48Z",
      "side": 1,
      "message": "You also get a different STL if you specify an sdk_version vs not specifying one. That was the immediate issue here.\n\nDo you know when one is expected to use the static vs shared one? Also why is the NDK one different from the usual one? We\u0027re interested in (eventually) taking the C++ Chromium certificate verifier and pulling it into BoringSSL, probably as a separate target initially. We\u0027re likely to try to get Conscrypt to use that code over the basically unmaintained crypto/x509 at some point.\n\nThat verifier will almost certainly depend on Abseil and expose its types (absl::optional, absl::span, etc) in the public API. Abseil is fun because it will require that everyone touching it be built against the same STL and the same C++ version. This is fine for Chromium and the internal repository, but I gather Android is a bit more... varied.",
      "parentUuid": "d5ca4789_0e79567e",
      "range": {
        "startLine": 34,
        "startChar": 24,
        "endLine": 34,
        "endChar": 31
      },
      "revId": "fc8a786995b661f44da82cba00d23b3f5e92653c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "71ab2cde_c432c04c",
        "filename": "Android.bp",
        "patchSetId": 1
      },
      "lineNbr": 34,
      "author": {
        "id": 1043845
      },
      "writtenOn": "2018-06-27T20:48:52Z",
      "side": 1,
      "message": "tl;dr probably shouldn\u0027t use libc++_static\n\nLike David points out, using the static STL can lead to problems if it\u0027s linked more than once. It can lead to really messy errors in some cases and should be avoided (singletons suddenly aren\u0027t so singular, global data might get double initialized, if the linker leaves two copies of a global only one of them might be initialized but the uninitialized might be used elsewhere, etc). It violates the one-definition-rule and that\u0027s undefined behavior, so it can cause undefined pain.\n\n\u003e PS: Whyyyyyy must you all have so many STLs in Android?? :-(\n\nWe don\u0027t. The platform supports only libc++. We used to have a bunch because there were three bad choices with different tradeoffs. The NDK still has the old STLs until r18 (releasing sometime next quarter) and they\u0027re deprecated in r17, but they are not accessible from the platform even when using sdk_version.\n\n\u003e Also why is the NDK one different from the usual one?\n\nSince the one installed to /system/lib is set it stone the moment it ships, it needs to be kept isolated from apps since the two might have divergent ABIs in the future. Platform symbols are std::__1::basic_string, NDK symbols are std::__ndk1::basic_string to keep these separate.",
      "parentUuid": "d9195c2a_1e4f85ca",
      "range": {
        "startLine": 34,
        "startChar": 24,
        "endLine": 34,
        "endChar": 31
      },
      "revId": "fc8a786995b661f44da82cba00d23b3f5e92653c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    }
  ]
}